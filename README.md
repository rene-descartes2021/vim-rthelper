
# RT Helper

RTHelper is a plugin that takes care of generating a JSON schema used for
validation by yaml-language-server on RobustToolbox YAML prototypes.

RTHelper uses a ctags tag file to generate the JSON schema.
This ctags tag file can also be used to navigate the YAML.

Vim can either be used interactively or non-interactively to run RTHelper.
The non-interactive mode can be used if the user wishes to use the schema
within a different IDE, and does not want to interact with Vim. This usage is
as follows, which could be for example called from the user's IDE or hooked
into the `RUN_THIS.py` RobustToolbox Content update script:
```bash
$ RTHELPER=/path/to/this/plugin ctags --exclude=@"$RTHELPER"/data/exclude.ctags --options="$RTHELPER"/data/cs.ctags --options="$RTHELPER"/data/yaml.ctags -f /tmp/rt.tags | vim -es +'RTGenSchema /tmp/rt.tags' +qall
```

| Key | Description |
| --- | --- |
| `Ctrl+]` | Jump to tag |
| `Ctrl+n` | Jump to next tag of same name (used in case of ambiguity) |
| `Ctrl+p` | Jump to previous tag of same name |
| `Ctrl+t` | Jump back up stack |

The use of tag jumping predates the use of language servers and does not
use context to resolve ambiguity: jumping to the next and previous tag works
around that. If using a different IDE, ctags plugins exist for those and can
be configured to use the tags file generated by this plugin.

## Why?

Navigating and making sense of RobustToolbox YAML files was difficult for me
and I thought to make a tool to do so as an exercise.

## Requirements?

The minimal requirements would be Vim and ctags.

I don't know the minimal Vim version or compiled features. If yours breaks
on something file an issue.

ctags should be compiled with +optscript and +pcre2 support (+optscript is new
to and bundled with v5.8 or so, and +pcre2 requires external Perl library):

```bash
$ctags --version
Universal Ctags 5.9.0(p5.9.20220807.0), Copyright (C) 2015-2022 Universal Ctags Team
Universal Ctags is derived from Exuberant Ctags.
Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert
  Compiled: Aug 13 2022, 13:33:55
  URL: https://ctags.io/
  Optional compiled features: +wildcards, +regex, +gnulib_regex, +iconv, +option-directory, +xpath, +json, +interactive, +packcc, +optscript, +pcre2
```

Note that ctags available within Debian package management is not compiled with
 the +pcre2 feature.

With just Vim and ctags this plugin can be used without launching Vim
interactively. The schema will be generated and able to be configured for use
by yaml-language-server within a different IDE.

### Minimal vimrc

If using MS Windows, you can substitute `$HOME/vimfiles` for `~/.vim` below.
See `:help vimrc` for details.

First clone the plugin:
```bash
mkdir -p ~/.vim/plugins
cd ~/.vim/plugins
$ git clone git@github.com:rene-descartes2021/vim-rthelper.git
```

Now make the minimal vimrc `~/.vim/vimrc` with contents:
```vim
set rtp+=~/.vim/plugins/vim-rthelper
source ~/.vim/plugins/vim-rthelper/plugin/rthelper.vim
```

### Interactive mode suggestions

ctags should be executable within Vim via `$PATH` or other Vim means.

The only suggested Vim plugin is [vim-gutentags](https://github.com/ludovicchabant/vim-gutentags).

And within your language server management plugin, install [yaml-language-server](https://github.com/redhat-developer/yaml-language-server).

If not using vim-lsp, a PR is welcome containing how to [initially configure](https://github.com/rene-descartes2021/vim-rthelper/blob/ef3b0116b29d24b00a2cfe80b54dcaf01fea8b16/plugin/rthelper.vim#L80)
yaml-language-server for your language server management plugin, [update that
configuration, and notify the server of a configuration change](https://github.com/rene-descartes2021/vim-rthelper/commit/ef3b0116b29d24b00a2cfe80b54dcaf01fea8b16#diff-c53120369733fbdf636fb01cffb609c2ed8e89585c1419b506af920ec8c2a302R131).
All guarded if necessary with something like
`if(exists(g:your_favorite_plugin))`.

The [integration with dein](https://github.com/rene-descartes2021/vim-rthelper/blob/ef3b0116b29d24b00a2cfe80b54dcaf01fea8b16/plugin/rthelper.vim#L35)
is in order to ensure that vim-gutentags is enabled for yaml and cs filetypes.
PRs to similarly integrate with other plugin managers,
or a more general trigger mechanism is acceptable.

## How?

When used interactively, integrates with [vim-gutentags](https://github.com/ludovicchabant/vim-gutentags),
[yaml-language-server](https://github.com/redhat-developer/yaml-language-server),
and if available: [vim-lsp](https://github.com/prabirshrestha/vim-lsp),
[vim-lsp-settings](https://github.com/mattn/vim-lsp-settings), and
[dein](https://github.com/Shougo/dein.vim).

Install RTHelper like any other Vim plugin. A minimal vimrc is supplied above
for non-interactive usage.

You can access Gutentags help pages with `:help gutentags`, and RTHelper's help
pages with `:help rthelper`.

The JSON schema is written within the content directory to:
`/Resources/Schemas/prototypes.json`.

## What?

RTHelper configures ctags to include the tags necessary. Neither the YAML and
C# parsers built into ctags were sufficient, so handmade regex mtables in
combination with ctags optscript were used. There is a bit of a slowdown
in not using the compiled built-in parsers, but those didn't supply the
necessary tag information. If another IDE has a ctags plugin, it can be
similarly configured to use the ctags options in this plugin's
`data/*.ctags` files.

### Vim interactive usage

Gutentags will (re)generate tag files as you work while staying
completely out of your way. It will even do its best to keep those tag files
out of your way too. It has no dependencies and just works.

RTHelper will then (re)generate the JSON schema and notify yaml-language-server
of the change using vim-lsp if available.

In order to generate tag files, Gutentags will have to figure out what's in
your project. To do this, it will locate well-known project root markers like
SCM folders (`.git`, `.hg`, etc.), any custom tags you define (with
`gutentags_project_root`), and even things you may have defined already with
other plugins, like CtrlP.

If the current file you're editing is found to be in such a project, Gutentags
will make sure the tag file for that project is up to date. Then, as you work
in files in that project, it will partially re-generate the tag file. Every
time you save, it will silently, in the background, update the tags for that
file.

Usually, ctags can only append tags to an existing tag file, so Gutentags
removes the tags for the current file first, to make sure the tag file is
always consistent with the source code.

Also, Gutentags is clever enough to not stumble upon itself by triggering
multiple ctags processes if you save files too fast, or your project is really
big.
